
## 1.Bitmap等大对象的优化策略

APP中的内存问题多半是因为Bitmap引起的。因此，解决Bitmap的问题就解决了一半的内存问题。要解决Bitmap的内存首先要知道Bitmap占用的内存是如何计算的。Bitmap的内存计算公式如下：

> 分辨率x一个像素点的大小


比如说一个1920x1080的图片，它所占用的内存就是1920x1080x一个像素点内存。

而一个像素点占用的内存又与Bitmap的配置参数有关系，比如通过下面的代码将Bitmap的inPreferredConfig配置成RGB_565的模式

```
  BitmapFactory.Options options = new BitmapFactory.Options();
  options.inPreferredConfig = Bitmap.Config.RGB_565;
```
除了RGB_565之外还有ARGB_4444、ARGB_8888、RGBA_F16等模式，在不同模式下单像素的占用内存如下表：

| Config | 占用内存（byte） | 说明 |
|--|--|--|
| ALPH_8 | 1 | 只包含一个透明通道,透明通道占用8bit，即1byte  |
| RGB_565 | 2 | 包含R/G/B三个颜色通道，不包含透明通道三个通道占用的内存分别为5bit/6bit/5bit |
| ARGB_4444 | 2 | 已废弃，包含A/R/G/B四个颜色通道，每个通道占用4bit |
| ARGB_8888 | 4 | 24位真彩色，Android默认配置，每个通道占用8bit |
| RGBA_F16 | 8 | Android8.0新增，每个通道占用16bit |

在Android系统中Bitmap的默认配置为ARGB_8888,即每个像素占用了4byte,那么在默认情况下，一张分辨率为1920*1080的图片的内存大小为1920*1080*4=7.91M

### （1）减小Bitmap对象的内存占用
了解了bitmap的内存的计算方式后，可以从两方面来着手优化图片的内存。即见效分辨率与减小单个像素点的大小

- 减小图片分辨率
通常APP加载一张图片时候，ImageView的大小是确定的，比如加载一个100*100的头像图片，但是Bitmap的分辨率是200*200，那么就可以将bitmap的分辨率压缩到100*100。通过这一压缩操作可以直接减少4倍的内存大小。

- 减小单个像素点的大小
很多情况下无需显示高清图片，可以将Bitmap的配置参数设置为ARGB_4444的模式，这样可以直接减少一半的内存占用。但是ARGB_4444由于导致图片失真，目前已经被废弃。如果图片中不包含透明通道，且需要保证图片的质量，则可以将bitmap配置为RGB_565的模式，其内存占用与ARGB_4444大小一样都为2个字节。另外，如果是一个只有透明通道的图片，那么完全可以将bitmap设置为ALPH_8的模式。

### （2）Bitmap的缓存策略
通过缓存策略也可以一定程度上的优化内存占用问题，比如Glide框架中采用了三级本地缓存策略来实现Bitmap的优化，通过设置活动缓存、LRU内存缓存和本地缓存。对于相同参数的ImageView，在内存中只保存一份，以此来减少内存大小。

### 资源文件需要选择合适的文件夹进行存放

例如我们只在hdpi的目录下放置了一张100*100的图片，那么根据换算关系，xxhdpi的手机去引用那张图片就会被拉伸到200*200。需要注意到在这种情况下，内存占用是会显著提高的。对于不希望被拉伸的图片，需要放到assets或者nodpi的目录下。

### 其他大对象的优化
可以使用更加轻量级的数据结构。例如，我们可以考虑使用ArrayMap/SparseArray而不是HashMap等传统数据结构，相比起Android系统专门为移动操作系统编写的ArrayMap容器，在大多数情况下，HashMap都显示效率低下，更占内存。另外，SparseArray更加高效在于，避免了对key与value的自动装箱，并且避免了装箱后的解箱。

## 避免内存抖动

内存抖动是指在短时间内突然创建大量的对象，频繁的引发GC回收，造成内存波动的情况。在开发中应该避免频繁的创建对象，来避免内存抖动。因为内存抖动会频繁出发GC，而GC机制又会引起STW问题。直接影响程序的性能。

比如在绘制自定义View的时候一定要避免在onDraw或者onMeasure中创建对象。

## 2.避免内存泄漏
Java的内存泄漏是指问题是指在对象使用结束后，由于一些地方持有该对象，虽然已经无用，但是无法被GC正常回收的情况。内存泄漏会引起很严重的性能问题，比如内存泄漏引起内存紧张，从而频繁的出发GC，而GC由于存在STW问题，又会引发更严重的性能问题。最终在分配新的对象时无法获得足够的内存空间时导致OOM的产生。

## 3.常见的内存泄漏

在实践操作当中，可以从四个方面着手减小内存使用，首先是减小对象的内存占用，其次是内存对象的重复利用，然后是避免对象的内存泄露，最后是内存使用策略优化。

### （1）单例模式引起的内存泄漏（Singleton）

为了完美解决我们在程序中反复创建同一对象的问题，我们选用了单例模式，单例在我们的程序中随处可见，但是由于单例模式的静态特性，使得它的生命周期和我们的应用一样长，一不小心让单例无限制的持有Activity的强引用就会导致内存泄漏。

### （2）Handler引起的内存泄漏

Handler引起的内存泄漏在我们开发中最为常见的。我们知道Handler、Message、MessageQueue都是相互关联在一起的，万一Handler发送的Message尚未被处理，那么该Message以及发送它的Handler对象都会被线程MessageQueue一直持有。 

### （3）匿名内部类在异步线程中的使用

它们方便却暗藏杀机。Android开发经常会继承实现 Activity 或者 Fragment 或者 View。如果你使用了匿名类，而又被异步线程所引用，那得小心，如果没有任何措施同样会导致内存泄漏的
由于Handler属于TLS（Thread Local Storage）变量，生命周期和Activity是不一致的，因此这种实现方式很难保证跟Activity的生命周期一直，所以很容易无法释放内存。

### （4）static引起的内存泄漏

从前面的介绍我们知道，static修饰的变量位于内存的静态存储区，此变量与App的生命周期一致 
这必然会导致一系列问题，如果你的app进程设计上是长驻内存的，那即使app切到后台，这部分内存也不会被释放。按照现在手机app内存管理机制，占内存较大的后台进程将优先回收，因为如果此app做过进程互保保活，那会造成app在后台频繁重启。当手机安装了你参与开发的app以后一夜时间手机被消耗空了电量、流量，你的app不得不被用户卸载或者静默。 
这里修复的方法是： 
不要在类初始时初始化静态成员。可以考虑lazy初始化（延迟加载）。架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。

### （5）非静态内部类引起的内存泄漏

非静态内部类的静态实例容易造成内存泄漏：即一个类中如果你不能够控制它其中内部类的生命周期（譬如Activity中的一些特殊Handler等），则尽量使用静态类和弱引用来处理（譬如ViewRoot的实现）。 

### （6）线程引起的内存泄漏

警惕线程未终止造成的内存泄露；譬如在Activity中关联了一个生命周期超过Activity的Thread，在退出Activity时切记结束线程。一个典型的例子就是HandlerThread的run方法是一个死循环，它不会自己结束，线程的生命周期超过了Activity生命周期，我们必须手动在Activity的销毁方法中中调运thread.getLooper().quit()才不会泄露。 

### （7）其他原因引起的内存泄漏

对象的注册与反注册没有成对出现造成的内存泄露；譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。 

创建与关闭没有成对出现造成的泄露；譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。 

避免代码设计模式的错误造成内存泄露；譬如循环引用，A持有B，B持有C，C持有A，这样的设计谁都得不到释放。
   
## 4.使用系统提供的API来释放内存
Android系统提供了一些回调来通知当前应用的内存使用情况，比如下边的两个方法：

- onLowMemory() 通常来说，当所有的Background应用都被kill掉的时候，forground应用会收到onLowMemory()的回调。在这种情况下，需要尽快释放当前应用的非必须的内存资源，从而确保系统能够继续稳定运行。尤其是要释放Glide中缓存的Bitmap资源，通过调用Glide.onLowMemory方法进行资源回收。

- onTrimMemory() Android系统从4.0开始还提供了onTrimMemory()的回调，当系统内存达到某些条件的时候，所有正在运行的应用都会收到这个回调，同时在这个回调里面会传递以下的参数，代表不同的内存使用情况，收到onTrimMemory()回调的时候，需要根据传递的参数类型进行判断，合理的选择释放自身的一些内存占用，一方面可以提高系统的整体运行流畅度，另外也可以避免自己被系统判断为优先需要杀掉的应用。例如调用Glide.onTrimMemory()来进行bitmap的回收。


## 5.常用排查内存问题的工具
### （1）LeakCanary监测内存泄漏
在debug模式下会一直开着LeakCanary来检测内存泄漏问题，根据LeanCannary提供的引用连可以快速定位到内存泄漏的位置。
### （2）通过Proflier监控内存
在一个功能开发完成后可以通过Profiler来检测APP的内存使用情况。反复的打开关闭页面，然后触发GC，内存是否能够减少。
### （3）通过MAT工具排查内存泄漏
MAT提供了很强大的功能，可以查看对象的深堆、浅堆的内存大小等。






